# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fKxBuK7xb_pax-YUO9tuJe7pfoNoL13G
"""



import pandas as pd

excel_file_path = '/content/Zaehldaten_Q3_2025.xlsx'
df = pd.read_excel(excel_file_path)

display(df.head())

num_unique_lines = df['Linie'].nunique()
print(f"There are {num_unique_lines} unique bus lines.")



df_line_660 = df[df['Linie'] == 660]
display(df_line_660.head())


# Check for missing values
print("Missing values per column:")
print(df_line_660.isnull().sum())

# Check for duplicate rows
print("\nNumber of duplicate rows:")
print(df_line_660.duplicated().sum())

# Get info about data types and non-null values
print("\nDataFrame Info:")
df_line_660.info()



"""# Task
Analyze passenger numbers for bus line 660 from the file "Zaehldaten_Q3_2025.xlsx".

## Calculate total passengers

### Subtask:
Calculate the total number of boarding passengers for line 660.

**Reasoning**:
Sum the 'Einsteiger' column in the `df_line_660` DataFrame to get the total boarding passengers for line 660 and print the result.
"""

total_boarding_passengers = df_line_660['Einsteiger'].sum()
print(f"Total number of boarding passengers for line 660: {total_boarding_passengers}")

"""## Analyze passengers per stop

### Subtask:
Determine which stops have the most and least boarding passengers.

**Reasoning**:
Group the data by stop name and sum the boarding passengers to find the stops with the most and least passengers.
"""

boarding_by_stop = df_line_660.groupby('HaltestelleName')['Einsteiger'].sum()

top_stops = boarding_by_stop.sort_values(ascending=False)
bottom_stops = boarding_by_stop.sort_values(ascending=True)

print("Stops with the most boarding passengers:")
display(top_stops.head())

print("\nStops with the least boarding passengers:")
display(bottom_stops.head())

"""\## Analyze passengers over time

### Subtask:
Examine how passenger numbers vary by day type (e.g., weekdays, weekends).

**Reasoning**:
Group the data by 'Tagesart', sum the 'Einsteiger' for each group, and then sort the results to see the variation in passenger numbers by day type.
"""

boarding_by_day_type = df_line_660.groupby('Tagesart')['Einsteiger'].sum()
sorted_boarding_by_day_type = boarding_by_day_type.sort_values(ascending=False)
print("Total boarding passengers by day type for line 660:")
display(sorted_boarding_by_day_type)



"""## Visualize passenger data

### Subtask:
Create visualizations to better understand the distribution of passengers.

**Reasoning**:
Create visualizations to understand the distribution of passengers by day type and the top/bottom stops.
"""

import matplotlib.pyplot as plt
import seaborn as sns

# 1. Bar chart of sorted_boarding_by_day_type
plt.figure(figsize=(10, 6))
sns.barplot(x=sorted_boarding_by_day_type.index, y=sorted_boarding_by_day_type.values)
plt.title('Total Boarding Passengers by Day Type for Line 660')
plt.xlabel('Day Type')
plt.ylabel('Total Boarding Passengers')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# 2. Bar chart of the top 10 stops
plt.figure(figsize=(12, 7))
sns.barplot(x=top_stops.head(10).index, y=top_stops.head(10).values)
plt.title('Top 10 Stops by Boarding Passengers for Line 660')
plt.xlabel('Stop Name')
plt.ylabel('Total Boarding Passengers')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# 3. Bar chart of the bottom 10 stops
plt.figure(figsize=(12, 7))
sns.barplot(x=bottom_stops.head(10).index, y=bottom_stops.head(10).values)
plt.title('Bottom 10 Stops by Boarding Passengers for Line 660')
plt.xlabel('Stop Name')
plt.ylabel('Total Boarding Passengers')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""## Summary:

### Data Analysis Key Findings

*   The total number of boarding passengers for bus line 660 in Q3 2025 is 196,365.
*   The stops with the most boarding passengers are "Zell/See Postplatz", "Zell am See Bahnhof", and "Kaprun Maiskogelbahn".
*   Several stops had zero boarding passengers during the analyzed period, including "Maish Az Neunbrunnen", "Maishofen Atzing", "Saalf Grünhäuslsiedl", "Saalf Gewerbegebiet", and "Saalf O-Gruber-Str".
*   Passenger numbers vary significantly by day type, with the highest numbers on weekdays during school holidays ("Mo-Fr Ferien" - 101,325 passengers), followed by weekdays during school terms ("Mo-Fr Schule" - 44,895 passengers). Weekend days ("Samstag" and "So/Feiertag") have considerably fewer passengers (25,110 and 25,035 respectively).

### Insights or Next Steps

*   Focus marketing or service adjustments on the top stops to maximize impact due to their high passenger volume.
*   Investigate the reasons for zero boarding passengers at certain stops to determine if service adjustments or stop removals are warranted.

"""

other_lines = df['Linie'].unique()
other_lines = other_lines[other_lines != 660]
print(other_lines)

import json
import math
import requests
import folium
from folium.plugins import MarkerCluster

OVERPASS_URL = "https://overpass-api.de/api/interpreter"

# Query template: fetch all child route relations (both directions/variants) and expand members with geometry
QUERY_TMPL = """
[out:json][timeout:180];
area["name"="Salzburg"]->.a;
rel["type"="route"]["route"="bus"]["ref"="{ref}"](area.a);
(._; >;);
out geom;
"""

def fetch_osm_route(ref: str):
    q = QUERY_TMPL.format(ref=ref)
    r = requests.post(OVERPASS_URL, data={"data": q})
    r.raise_for_status()
    return r.json()

def build_maps_for_ref(ref: str):
    data = fetch_osm_route(ref)

    # Index elements
    ways_by_id = {}
    nodes_by_id = {}
    relations = []
    for el in data.get("elements", []):
        if el["type"] == "way":
            ways_by_id[el["id"]] = el
        elif el["type"] == "node":
            nodes_by_id[el["id"]] = el
        elif el["type"] == "relation":
            # Keep only bus route relations
            if el.get("tags", {}).get("route") == "bus":
                relations.append(el)

    # If nothing came back, bail out nicely
    if not relations:
        print(f"[{ref}] No OSM bus relations found in Salzburg.")
        return

    # Collect all coordinates for centering & bounds
    all_coords = []
    for w in ways_by_id.values():
        for pt in w.get("geometry", []):
            all_coords.append((pt["lat"], pt["lon"]))

    if not all_coords:
        # fallback: try to center on any stop node
        for n in nodes_by_id.values():
            all_coords.append((n["lat"], n["lon"]))
    if not all_coords:
        print(f"[{ref}] No geometry found.")
        return

    # Compute center/bounds
    min_lat = min(lat for lat, _ in all_coords)
    max_lat = max(lat for lat, _ in all_coords)
    min_lon = min(lon for _, lon in all_coords)
    max_lon = max(lon for _, lon in all_coords)
    center = ((min_lat + max_lat) / 2.0, (min_lon + max_lon) / 2.0)

    # Make map
    m = folium.Map(location=center, zoom_start=11, control_scale=True)

    # A layer per direction/variant (per relation)
    # We’ll name the layer with relation name/ref/role if available
    for idx, rel in enumerate(relations, start=1):
        name = rel.get("tags", {}).get("name") or f"Route {ref} variant {idx}"
        rel_group = folium.FeatureGroup(name=name, show=True)
        # Members may include ways (route geometry) and nodes (stops)
        way_ids = [memb["ref"] for memb in rel.get("members", []) if memb["type"] == "way"]
        for wid in way_ids:
            way = ways_by_id.get(wid)
            if not way:
                continue
            coords = [(pt["lat"], pt["lon"]) for pt in way.get("geometry", [])]
            if len(coords) >= 2:
                folium.PolyLine(locations=coords, weight=4, opacity=0.9).add_to(rel_group)
        rel_group.add_to(m)

    # Stops layer (clustered)
    stop_group = folium.FeatureGroup(name=f"Stops {ref}", show=True)
    stop_cluster = MarkerCluster()
    stop_group.add_child(stop_cluster)

    def is_stop_node(n):
        t = n.get("tags", {})
        # Most common stop tags in OSM
        if t.get("highway") == "bus_stop":
            return True
        if t.get("public_transport") in {"platform", "stop_position"} and (t.get("bus") == "yes" or "bus" in t):
            return True
        return False

    # Two sources of stop nodes:
    # 1) Nodes explicitly tagged as stops in the elements
    # 2) Node members of the route relations with stop-ish roles
    stop_ids = set()

    # From global node set
    for nid, node in nodes_by_id.items():
        if is_stop_node(node):
            stop_ids.add(nid)

    # From relation members by role
    STOP_ROLES = {"stop", "stop_entry_only", "stop_exit_only", "platform", "platform_entry_only", "platform_exit_only"}
    for rel in relations:
        for memb in rel.get("members", []):
            if memb["type"] == "node" and memb.get("role") in STOP_ROLES:
                stop_ids.add(memb["ref"])

    for nid in stop_ids:
        node = nodes_by_id.get(nid)
        if not node:
            continue
        lat, lon = node["lat"], node["lon"]
        t = node.get("tags", {})
        title = t.get("name") or "Stop"
        ref_tag = t.get("ref")
        popup_lines = [f"<b>{title}</b>"]
        if ref_tag:
            popup_lines.append(f"Ref: {ref_tag}")
        # Show some common extra tags if present
        for k in ("network", "operator", "local_ref", "naptan:AtcoCode"):
            if t.get(k):
                popup_lines.append(f"{k}: {t[k]}")
        folium.Marker((lat, lon), tooltip=title, popup=folium.Popup("<br>".join(popup_lines), max_width=300)).add_to(stop_cluster)

    stop_group.add_to(m)

    # Fit to bounds
    m.fit_bounds([[min_lat, min_lon], [max_lat, max_lon]])

    out_name = f"bus_{ref}.html"
    m.save(out_name)
    print(f"[{ref}] Wrote {out_name}")

if __name__ == "__main__":
    for ref in ("660", "670", "673"):
        build_maps_for_ref(ref)

import requests
import json
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from collections import defaultdict

# Define the bus routes we want to visualize
# Note: Some routes use route_master relations that contain child route relations
bus_routes = {
    '660': ['1852094', '10587835'],  # Zell am See <=> Kaprun (both directions)
    '670': '10599491',  # Zell am See <=> Krimml
    '673': '10601324'   # Wald/Pzg <=> Königsleiten
}

def fetch_route_from_overpass(relation_id):
    """
    Fetch bus route data from Overpass API
    """
    overpass_url = "https://overpass-api.de/api/interpreter"

    # Overpass query to get the relation with all its ways and nodes
    overpass_query = f"""
    [out:json][timeout:60];
    (
      relation({relation_id});
      >;
    );
    out body;
    """

    try:
        response = requests.post(overpass_url, data={'data': overpass_query})
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching relation {relation_id}: {e}")
        return None

def extract_coordinates(data):
    """
    Extract coordinates from Overpass API response
    """
    if not data or 'elements' not in data:
        return []

    # Create a dictionary of nodes with their coordinates
    nodes = {}
    ways = []
    relations = []

    for element in data['elements']:
        if element['type'] == 'node':
            nodes[element['id']] = (element['lat'], element['lon'])
        elif element['type'] == 'way' and 'nodes' in element:
            # Only include ways that have a 'route' role or no role
            # Skip 'platform' and 'stop' ways as they're not part of the actual route
            if 'tags' in element:
                # Ways with highway tags are likely part of the route
                if 'highway' in element['tags']:
                    ways.append(element['nodes'])
            else:
                # If no tags, include it (could be part of route)
                ways.append(element['nodes'])
        elif element['type'] == 'relation':
            relations.append(element)

    # Convert ways to coordinate sequences
    coordinates = []
    for way in ways:
        way_coords = []
        for node_id in way:
            if node_id in nodes:
                way_coords.append(nodes[node_id])
        if way_coords:
            coordinates.append(way_coords)

    return coordinates

def plot_bus_routes():
    """
    Plot all three bus routes on a single map
    """
    fig, ax = plt.subplots(figsize=(14, 10))

    colors = {
        '660': '#FF6B6B',  # Red
        '670': '#4ECDC4',  # Teal
        '673': '#FFD93D'   # Yellow
    }

    route_names = {
        '660': 'Bus 660: Zell am See ↔ Kaprun',
        '670': 'Bus 670: Zell am See ↔ Krimml',
        '673': 'Bus 673: Wald/Pzg ↔ Königsleiten'
    }

    all_lats = []
    all_lons = []

    for route_num, relation_ids in bus_routes.items():
        # Handle both single relation ID and list of relation IDs
        if isinstance(relation_ids, str):
            relation_ids = [relation_ids]

        print(f"Fetching data for Bus {route_num}...")
        all_coordinates = []

        for relation_id in relation_ids:
            print(f"  Querying relation {relation_id}...")
            data = fetch_route_from_overpass(relation_id)

            if data:
                coordinates = extract_coordinates(data)
                all_coordinates.extend(coordinates)
                if coordinates:
                    print(f"    Found {len(coordinates)} way segments")
            else:
                print(f"    Failed to fetch data")

        if all_coordinates:
            print(f"  Total: {len(all_coordinates)} way segments for Bus {route_num}")

            # Plot each way segment
            for way_coords in all_coordinates:
                if len(way_coords) >= 2:
                    lats, lons = zip(*way_coords)
                    all_lats.extend(lats)
                    all_lons.extend(lons)

                    ax.plot(lons, lats,
                           color=colors[route_num],
                           linewidth=2,
                           alpha=0.7,
                           solid_capstyle='round')
        else:
            print(f"  No coordinates found for Bus {route_num}")

    # Set plot limits with some padding
    if all_lats and all_lons:
        lat_margin = (max(all_lats) - min(all_lats)) * 0.1
        lon_margin = (max(all_lons) - min(all_lons)) * 0.1

        ax.set_xlim(min(all_lons) - lon_margin, max(all_lons) + lon_margin)
        ax.set_ylim(min(all_lats) - lat_margin, max(all_lats) + lat_margin)

    # Create legend
    legend_elements = [
        mpatches.Patch(color=colors['660'], label=route_names['660']),
        mpatches.Patch(color=colors['670'], label=route_names['670']),
        mpatches.Patch(color=colors['673'], label=route_names['673'])
    ]
    ax.legend(handles=legend_elements, loc='upper right', fontsize=10)

    # Labels and styling
    ax.set_xlabel('Longitude', fontsize=12)
    ax.set_ylabel('Latitude', fontsize=12)
    ax.set_title('Salzburg Bus Routes: 660, 670, and 673', fontsize=16, fontweight='bold')
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.set_aspect('equal', adjustable='box')

    # Add attribution
    ax.text(0.02, 0.02, '© OpenStreetMap contributors',
            transform=ax.transAxes, fontsize=8,
            verticalalignment='bottom', alpha=0.7)

    plt.tight_layout()
    plt.savefig('salzburg_bus_routes.png', dpi=300, bbox_inches='tight')
    print("\nMap saved as 'salzburg_bus_routes.png'")
    plt.show()

if __name__ == "__main__":
    print("Salzburg Bus Routes Visualization")
    print("=" * 50)
    print("Fetching bus routes from OpenStreetMap via Overpass API...\n")

    plot_bus_routes()

    print("\nVisualization complete!")

def print_villages_info(villages_by_route):
    """Print detailed information about villages by route"""
    print(f"\n{'='*70}")
    print(f"Villages Along Each Route")
    print(f"{'='*70}")
import requests
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.lines import Line2D

# Define the bus routes
bus_routes = {
    '660': {
        'relations': ['1852094', '10587835'],
        'name': 'Bus 660: Zell am See ↔ Kaprun',
        'color': '#FF0000'  # Red
    },
    '670': {
        'relations': ['1852115', '10599642'],
        'name': 'Bus 670: Zell am See ↔ Krimml',
        'color': '#00FFFF'  # Cyan
    },
    '673': {
        'relations': ['10601324'],
        'name': 'Bus 673: Wald/Pzg ↔ Königsleiten',
        'color': '#FFD700'  # Gold
    }
}

def fetch_route_from_overpass(relation_id):
    """Fetch bus route data from Overpass API"""
    overpass_url = "https://overpass-api.de/api/interpreter"

    overpass_query = f"""
    [out:json][timeout:90];
    (
      relation({relation_id});
      >>;
    );
    out body;
    """

    try:
        print(f"      Fetching relation {relation_id}...")
        response = requests.post(overpass_url, data={'data': overpass_query}, timeout=120)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"      Error: {e}")
        return None

def extract_route_data(data):
    """Extract coordinates and bus stops from Overpass API response"""
    if not data or 'elements' not in data:
        return [], []

    nodes = {}
    ways = {}
    bus_stops = []

    # First pass: collect nodes, ways, and identify bus stops
    for element in data['elements']:
        if element['type'] == 'node' and 'lat' in element and 'lon' in element:
            nodes[element['id']] = {
                'lat': element['lat'],
                'lon': element['lon'],
                'tags': element.get('tags', {})
            }

            # Check if this node is a bus stop
            tags = element.get('tags', {})
            if (tags.get('highway') == 'bus_stop' or
                tags.get('public_transport') in ['stop_position', 'platform']):
                stop_name = tags.get('name', 'Unnamed Stop')
                bus_stops.append({
                    'name': stop_name,
                    'lat': element['lat'],
                    'lon': element['lon'],
                    'ref': tags.get('ref', ''),
                    'type': tags.get('public_transport', 'bus_stop')
                })
        elif element['type'] == 'way':
            ways[element['id']] = element

    # Second pass: extract way coordinates (route paths)
    route_ways = []
    for way_id, way_data in ways.items():
        # Skip platforms and buildings
        if 'tags' in way_data:
            tags = way_data['tags']
            if tags.get('public_transport') == 'platform':
                continue
            if tags.get('highway') == 'platform':
                continue
            if 'building' in tags:
                continue

        # Get coordinates for this way
        if 'nodes' in way_data:
            way_coords = []
            for node_id in way_data['nodes']:
                if node_id in nodes:
                    node = nodes[node_id]
                    way_coords.append((node['lat'], node['lon']))

            if len(way_coords) >= 2:
                route_ways.append(way_coords)

    return route_ways, bus_stops

def fetch_hotels_near_route(min_lat, max_lat, min_lon, max_lon):
    """Fetch hotels and accommodations near the route"""
    overpass_url = "https://overpass-api.de/api/interpreter"

    # Add some padding to the bounding box
    lat_padding = (max_lat - min_lat) * 0.05
    lon_padding = (max_lon - min_lon) * 0.05

    overpass_query = f"""
    [out:json][timeout:60];
    (
      node["tourism"="hotel"]({min_lat - lat_padding},{min_lon - lon_padding},{max_lat + lat_padding},{max_lon + lon_padding});
      node["tourism"="guest_house"]({min_lat - lat_padding},{min_lon - lon_padding},{max_lat + lat_padding},{max_lon + lon_padding});
      node["tourism"="hostel"]({min_lat - lat_padding},{min_lon - lon_padding},{max_lat + lat_padding},{max_lon + lon_padding});
    );
    out body;
    """

    try:
        print("\nFetching hotels and accommodations...")
        response = requests.post(overpass_url, data={'data': overpass_query}, timeout=120)
        response.raise_for_status()
        data = response.json()

        hotels = []
        for element in data.get('elements', []):
            if element['type'] == 'node' and 'lat' in element and 'lon' in element:
                tags = element.get('tags', {})
                hotels.append({
                    'name': tags.get('name', 'Unnamed'),
                    'type': tags.get('tourism', 'hotel'),
                    'lat': element['lat'],
                    'lon': element['lon'],
                    'stars': tags.get('stars', ''),
                    'phone': tags.get('phone', ''),
                    'website': tags.get('website', '')
                })

        print(f"  ✓ Found {len(hotels)} hotels/accommodations")
        return hotels
    except Exception as e:
        print(f"  ✗ Error fetching hotels: {e}")
        return []

def fetch_villages_for_route(route_coords):
    """Fetch villages near a specific route"""
    # Get bounding box for this specific route
    all_lats = []
    all_lons = []
    for way_coords in route_coords:
        for lat, lon in way_coords:
            all_lats.append(lat)
            all_lons.append(lon)

    if not all_lats or not all_lons:
        return []

    min_lat, max_lat = min(all_lats), max(all_lats)
    min_lon, max_lon = min(all_lons), max(all_lons)

    # Add padding
    lat_padding = (max_lat - min_lat) * 0.1
    lon_padding = (max_lon - min_lon) * 0.1

    overpass_url = "https://overpass-api.de/api/interpreter"

    overpass_query = f"""
    [out:json][timeout:60];
    (
      node["place"="village"]({min_lat - lat_padding},{min_lon - lon_padding},{max_lat + lat_padding},{max_lon + lon_padding});
    );
    out body;
    """

    try:
        response = requests.post(overpass_url, data={'data': overpass_query}, timeout=120)
        response.raise_for_status()
        data = response.json()

        places = []
        for element in data.get('elements', []):
            if element['type'] == 'node' and 'lat' in element and 'lon' in element:
                tags = element.get('tags', {})
                places.append({
                    'name': tags.get('name', 'Unnamed'),
                    'lat': element['lat'],
                    'lon': element['lon'],
                    'population': tags.get('population', ''),
                    'wikipedia': tags.get('wikipedia', '')
                })

        return places
    except Exception as e:
        print(f"      ✗ Error fetching villages: {e}")
        return []

def print_route_info(route_num, bus_stops):
    """Print detailed information about bus stops"""
    print(f"\n{'='*70}")
    print(f"Bus {route_num} - Stop Details")
    print(f"{'='*70}")

    if not bus_stops:
        print("  No stops found")
        return

    # Remove duplicates based on name
    unique_stops = {}
    for stop in bus_stops:
        if stop['name'] not in unique_stops:
            unique_stops[stop['name']] = stop

    stops_list = list(unique_stops.values())

    print(f"Total Stops: {len(stops_list)}\n")

    for i, stop in enumerate(stops_list, 1):
        ref = f" [{stop['ref']}]" if stop['ref'] else ""
        print(f"{i:3d}. {stop['name']}{ref}")
        print(f"      Location: {stop['lat']:.5f}°N, {stop['lon']:.5f}°E")

def print_hotel_info(hotels):
    """Print detailed information about hotels"""
    print(f"\n{'='*70}")
    print(f"Hotels and Accommodations Near Routes")
    print(f"{'='*70}")

    if not hotels:
        print("  No hotels found")
        return

    # Sort by type
    hotels_by_type = {}
    for hotel in hotels:
        htype = hotel['type']
        if htype not in hotels_by_type:
            hotels_by_type[htype] = []
        hotels_by_type[htype].append(hotel)

    for htype, hlist in hotels_by_type.items():
        print(f"\n{htype.upper()}S ({len(hlist)}):")
        for hotel in sorted(hlist, key=lambda x: x['name']):
            stars = f" {'★' * int(hotel['stars'])}" if hotel['stars'] else ""
            print(f"  • {hotel['name']}{stars}")
            print(f"    Location: {hotel['lat']:.5f}°N, {hotel['lon']:.5f}°E")
            if hotel['phone']:
                print(f"    Phone: {hotel['phone']}")
            if hotel['website']:
                print(f"    Website: {hotel['website']}")

def create_villages_by_route_chart(villages_by_route):
    """Create a chart showing villages grouped by bus route"""
    print("\nCreating villages by route chart...")

    # Prepare data
    route_labels = []
    village_names = []
    route_numbers = []

    for route_num in ['660', '670', '673']:
        if route_num in villages_by_route:
            villages = villages_by_route[route_num]
            for village in sorted(villages, key=lambda x: x['name']):
                village_names.append(village['name'])
                route_numbers.append(route_num)
                route_labels.append(f"Bus {route_num}")

    if not village_names:
        print("  No villages to chart")
        return

    # Create figure
    fig, ax = plt.subplots(figsize=(20, 12))

    # Create positions for bars
    positions = list(range(len(village_names)))

    # Color map for routes
    colors_map = {
        '660': '#FF0000',  # Red
        '670': '#00FFFF',  # Cyan
        '673': '#FFD700'   # Gold
    }

    # Create colored bars
    bar_colors = [colors_map[rn] for rn in route_numbers]
    bars = ax.bar(positions, [1]*len(village_names), color=bar_colors,
                  edgecolor='white', linewidth=2, alpha=0.8)

    # Customize
    ax.set_xticks(positions)
    ax.set_xticklabels(village_names, rotation=45, ha='right', fontsize=14)
    ax.set_ylabel('Bus Route', fontsize=16, fontweight='bold')
    ax.set_xlabel('Villages', fontsize=16, fontweight='bold')
    ax.set_title('Villages Served by Each Bus Route', fontsize=20, fontweight='bold', pad=20)
    ax.set_ylim(0, 1.2)
    ax.set_yticks([])

    # Add route labels on bars
    for i, (pos, route_num) in enumerate(zip(positions, route_numbers)):
        ax.text(pos, 0.5, f'Bus {route_num}',
               ha='center', va='center',
               fontsize=12, fontweight='bold',
               color='white',
               bbox=dict(boxstyle='round,pad=0.3', facecolor='black', alpha=0.7))

    # Create legend
    from matplotlib.patches import Patch
    legend_elements = [
        Patch(facecolor='#FF0000', edgecolor='white', label='Bus 660: Zell am See ↔ Kaprun'),
        Patch(facecolor='#00FFFF', edgecolor='white', label='Bus 670: Zell am See ↔ Krimml'),
        Patch(facecolor='#FFD700', edgecolor='white', label='Bus 673: Wald/Pzg ↔ Königsleiten')
    ]
    ax.legend(handles=legend_elements, loc='upper right', fontsize=14, framealpha=0.95)

    ax.grid(True, axis='x', alpha=0.3)
    plt.tight_layout()

    # Save
    filename = 'salzburg_villages_by_route_chart.png'
    plt.savefig(filename, dpi=300, bbox_inches='tight', facecolor='white')
    print(f"  ✓ Chart saved as '{filename}'")
    plt.show()
    """Print detailed information about villages by route"""
    print(f"\n{'='*70}")
    print(f"Villages Along Each Route")
    print(f"{'='*70}")

    for route_num, villages in villages_by_route.items():
        route_name = bus_routes[route_num]['name']
        print(f"\n{route_name}")
        print("-" * 70)

        if not villages:
            print("  No villages found")
            continue

        print(f"Total: {len(villages)} villages\n")

        for i, village in enumerate(sorted(villages, key=lambda x: x['name']), 1):
            pop_info = f" (pop: {village['population']})" if village['population'] else ""
            print(f"{i:3d}. {village['name']}{pop_info}")
            print(f"      Location: {village['lat']:.5f}°N, {village['lon']:.5f}°E")
            if village['wikipedia']:
                print(f"      Wikipedia: {village['wikipedia']}")

def plot_routes_with_stops_and_hotels():
    """Main plotting function with stops and hotels"""
    print("="*70)
    print("Salzburg Bus Routes - Detailed Analysis")
    print("="*70)
    print("\nFetching route data from OpenStreetMap...")

    # Fetch all routes
    route_data = {}
    all_coords = []
    all_stops = {}
    villages_by_route = {}

    for route_num, route_info in bus_routes.items():
        print(f"\n[Bus {route_num}] {route_info['name']}")
        route_coords = []
        route_stops = []

        for relation_id in route_info['relations']:
            data = fetch_route_from_overpass(relation_id)
            if data:
                coords, stops = extract_route_data(data)
                route_coords.extend(coords)
                route_stops.extend(stops)
                if coords:
                    print(f"      ✓ {len(coords)} segments, {len(stops)} stops")

        if route_coords:
            route_data[route_num] = route_coords
            all_coords.extend(route_coords)
            all_stops[route_num] = route_stops

            # Fetch villages for this specific route
            print(f"      Fetching villages for Bus {route_num}...")
            villages = fetch_villages_for_route(route_coords)
            villages_by_route[route_num] = villages
            print(f"      ✓ Found {len(villages)} villages")

            print(f"   → Total: {len(route_coords)} segments, {len(route_stops)} stops, {len(villages)} villages")
        else:
            print(f"   ✗ No data found")

    if not all_coords:
        print("\n✗ No route data available!")
        return

    # Get coordinate bounds
    all_lats = []
    all_lons = []
    for way_coords in all_coords:
        for lat, lon in way_coords:
            all_lats.append(lat)
            all_lons.append(lon)

    min_lat, max_lat = min(all_lats), max(all_lats)
    min_lon, max_lon = min(all_lons), max(all_lons)

    # Fetch hotels
    hotels = fetch_hotels_near_route(min_lat, max_lat, min_lon, max_lon)

    # Print detailed information
    for route_num, stops in all_stops.items():
        print_route_info(route_num, stops)

    print_villages_info(villages_by_route)
    print_hotel_info(hotels)

    # Create villages by route chart
    create_villages_by_route_chart(villages_by_route)

    print(f"\n{'='*70}")
    print("Creating visualization...")
    print(f"{'='*70}")

    # Create plot with much larger size
    fig, ax = plt.subplots(figsize=(40, 30))

    # Set nice background
    ax.set_facecolor('#F5F5F5')
    ax.grid(True, alpha=0.3, linestyle='--', linewidth=1.5, color='#888888')

    # Plot routes with much thicker lines
    print("\nPlotting routes...")
    for route_num, coords_list in route_data.items():
        route_info = bus_routes[route_num]
        for way_coords in coords_list:
            if len(way_coords) >= 2:
                lats, lons = zip(*way_coords)
                ax.plot(lons, lats,
                       color=route_info['color'],
                       linewidth=12,
                       alpha=0.8,
                       solid_capstyle='round',
                       zorder=5)

    # Plot bus stops - much larger
    print("Plotting bus stops...")
    for route_num, stops in all_stops.items():
        route_info = bus_routes[route_num]
        if stops:
            stop_lats = [s['lat'] for s in stops]
            stop_lons = [s['lon'] for s in stops]
            ax.scatter(stop_lons, stop_lats,
                      c=route_info['color'],
                      s=600,
                      marker='o',
                      edgecolors='white',
                      linewidths=5,
                      alpha=0.9,
                      zorder=10,
                      label=f'Bus {route_num} stops')

    # Plot hotels - much larger
    print("Plotting hotels...")
    if hotels:
        hotel_lats = [h['lat'] for h in hotels]
        hotel_lons = [h['lon'] for h in hotels]
        ax.scatter(hotel_lons, hotel_lats,
                  c='#8B4513',  # Brown
                  s=800,
                  marker='s',  # Square
                  edgecolors='white',
                  linewidths=5,
                  alpha=0.8,
                  zorder=15,
                  label=f'Hotels ({len(hotels)})')

    # Plot villages by route with different colors - much larger
    print("Plotting villages by route...")
    if villages_by_route:
        # Color villages by which route they belong to
        for route_num, villages in villages_by_route.items():
            route_info = bus_routes[route_num]
            if villages:
                for village in villages:
                    # Use a lighter shade of the route color for villages
                    ax.scatter(village['lon'], village['lat'],
                              c=route_info['color'],
                              s=700,
                              marker='^',  # Triangle
                              edgecolors='white',
                              linewidths=5,
                              alpha=0.7,
                              zorder=12)

                    # Add village name as text with route-colored box - much larger
                    ax.annotate(village['name'],
                               xy=(village['lon'], village['lat']),
                               xytext=(10, 10),
                               textcoords='offset points',
                               fontsize=22,
                               fontweight='bold',
                               color='#000000',
                               bbox=dict(boxstyle='round,pad=0.8',
                                        facecolor=route_info['color'],
                                        edgecolor='white',
                                        linewidth=3,
                                        alpha=0.8),
                               zorder=20)

    # Set bounds with padding
    lat_padding = (max_lat - min_lat) * 0.05
    lon_padding = (max_lon - min_lon) * 0.05

    ax.set_xlim(min_lon - lon_padding, max_lon + lon_padding)
    ax.set_ylim(min_lat - lat_padding, max_lat + lat_padding)

    # Create custom legend
    legend_elements = []

    # Routes
    for route_num in ['660', '670', '673']:
        if route_num in route_data:
            info = bus_routes[route_num]
            legend_elements.append(
                Line2D([0], [0], color=info['color'], linewidth=4,
                       label=info['name'])
            )

    # Stops and hotels
    legend_elements.append(
        Line2D([0], [0], marker='o', color='w',
               markerfacecolor='gray', markersize=10,
               markeredgecolor='white', markeredgewidth=2,
               label='Bus Stops', linestyle='None')
    )

    if hotels:
        legend_elements.append(
            Line2D([0], [0], marker='s', color='w',
                   markerfacecolor='#8B4513', markersize=10,
                   markeredgecolor='white', markeredgewidth=2,
                   label=f'Hotels/Accommodations ({len(hotels)})',
                   linestyle='None')
        )

    if villages:
        legend_elements.append(
            Line2D([0], [0], marker='^', color='w',
                   markerfacecolor='#4169E1', markersize=10,
                   markeredgecolor='white', markeredgewidth=2,
                   label=f'Villages ({len(villages)})',
                   linestyle='None')
        )

    ax.legend(handles=legend_elements,
             loc='upper right',
             fontsize=13,
             framealpha=0.95,
             edgecolor='black',
             shadow=True)

    # Labels and title - much larger text
    ax.set_xlabel('Longitude (°E)', fontsize=28, fontweight='bold', labelpad=15)
    ax.set_ylabel('Latitude (°N)', fontsize=28, fontweight='bold', labelpad=15)

    # Larger tick labels
    ax.tick_params(axis='both', which='major', labelsize=24, width=2, length=10)

    total_stops = sum(len(stops) for stops in all_stops.values())
    total_villages = sum(len(v) for v in villages_by_route.values())
    ax.set_title(f'Salzburg Regional Bus Routes - Detailed Map\n'
                 f'Lines 660, 670, 673 | {total_stops} stops | {total_villages} villages | {len(hotels)} hotels',
                 fontsize=36, fontweight='bold', pad=30)

    # Attribution - larger
    ax.text(0.02, 0.02, '© OpenStreetMap contributors',
            transform=ax.transAxes, fontsize=18,
            verticalalignment='bottom',
            bbox=dict(boxstyle='round,pad=0.8', facecolor='white',
                     edgecolor='black', linewidth=2, alpha=0.9))

    ax.set_aspect('equal', adjustable='box')
    plt.tight_layout()

    # Save
    filename = 'salzburg_bus_routes_detailed.png'
    plt.savefig(filename, dpi=300, bbox_inches='tight', facecolor='white')
    print(f"\n✓ Map saved as '{filename}'")

    # Display
    print("✓ Displaying map...")
    plt.show()

    print("\n" + "="*70)
    print("Analysis Complete!")
    print(f"Routes: {len(route_data)}")
    print(f"Total Stops: {sum(len(stops) for stops in all_stops.values())}")
    print(f"Villages: {sum(len(v) for v in villages_by_route.values())}")
    print(f"Hotels Found: {len(hotels)}")
    print("="*70)

if __name__ == "__main__":
    try:
        plot_routes_with_stops_and_hotels()
    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
    except Exception as e:
        print(f"\n✗ Error: {e}")
        import traceback
        traceback.print_exc()

def print_villages_info(villages_by_route):
    """Print detailed information about villages by route"""
    print(f"\n{'='*70}")
    print(f"Villages Along Each Route")
    print(f"{'='*70}")
import requests
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.lines import Line2D

# Define the bus routes
bus_routes = {
    '660': {
        'relations': ['1852094', '10587835'],
        'name': 'Bus 660: Zell am See ↔ Kaprun',
        'color': '#FF0000'  # Red
    },
    '670': {
        'relations': ['1852115', '10599642'],
        'name': 'Bus 670: Zell am See ↔ Krimml',
        'color': '#00FFFF'  # Cyan
    },
    '673': {
        'relations': ['10601324'],
        'name': 'Bus 673: Wald/Pzg ↔ Königsleiten',
        'color': '#FFD700'  # Gold
    }
}

def fetch_route_from_overpass(relation_id):
    """Fetch bus route data from Overpass API"""
    overpass_url = "https://overpass-api.de/api/interpreter"

    overpass_query = f"""
    [out:json][timeout:90];
    (
      relation({relation_id});
      >>;
    );
    out body;
    """

    try:
        print(f"      Fetching relation {relation_id}...")
        response = requests.post(overpass_url, data={'data': overpass_query}, timeout=120)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        print(f"      Error: {e}")
        return None

def extract_route_data(data):
    """Extract coordinates and bus stops from Overpass API response"""
    if not data or 'elements' not in data:
        return [], []

    nodes = {}
    ways = {}
    bus_stops = []

    # First pass: collect nodes, ways, and identify bus stops
    for element in data['elements']:
        if element['type'] == 'node' and 'lat' in element and 'lon' in element:
            nodes[element['id']] = {
                'lat': element['lat'],
                'lon': element['lon'],
                'tags': element.get('tags', {})
            }

            # Check if this node is a bus stop
            tags = element.get('tags', {})
            if (tags.get('highway') == 'bus_stop' or
                tags.get('public_transport') in ['stop_position', 'platform']):
                stop_name = tags.get('name', 'Unnamed Stop')
                bus_stops.append({
                    'name': stop_name,
                    'lat': element['lat'],
                    'lon': element['lon'],
                    'ref': tags.get('ref', ''),
                    'type': tags.get('public_transport', 'bus_stop')
                })
        elif element['type'] == 'way':
            ways[element['id']] = element

    # Second pass: extract way coordinates (route paths)
    route_ways = []
    for way_id, way_data in ways.items():
        # Skip platforms and buildings
        if 'tags' in way_data:
            tags = way_data['tags']
            if tags.get('public_transport') == 'platform':
                continue
            if tags.get('highway') == 'platform':
                continue
            if 'building' in tags:
                continue

        # Get coordinates for this way
        if 'nodes' in way_data:
            way_coords = []
            for node_id in way_data['nodes']:
                if node_id in nodes:
                    node = nodes[node_id]
                    way_coords.append((node['lat'], node['lon']))

            if len(way_coords) >= 2:
                route_ways.append(way_coords)

    return route_ways, bus_stops

def fetch_hotels_near_route(min_lat, max_lat, min_lon, max_lon):
    """Fetch hotels and accommodations near the route"""
    overpass_url = "https://overpass-api.de/api/interpreter"

    # Add some padding to the bounding box
    lat_padding = (max_lat - min_lat) * 0.05
    lon_padding = (max_lon - min_lon) * 0.05

    overpass_query = f"""
    [out:json][timeout:60];
    (
      node["tourism"="hotel"]({min_lat - lat_padding},{min_lon - lon_padding},{max_lat + lat_padding},{max_lon + lon_padding});
      node["tourism"="guest_house"]({min_lat - lat_padding},{min_lon - lon_padding},{max_lat + lat_padding},{max_lon + lon_padding});
      node["tourism"="hostel"]({min_lat - lat_padding},{min_lon - lon_padding},{max_lat + lat_padding},{max_lon + lon_padding});
    );
    out body;
    """

    try:
        print("\nFetching hotels and accommodations...")
        response = requests.post(overpass_url, data={'data': overpass_query}, timeout=120)
        response.raise_for_status()
        data = response.json()

        hotels = []
        for element in data.get('elements', []):
            if element['type'] == 'node' and 'lat' in element and 'lon' in element:
                tags = element.get('tags', {})
                hotels.append({
                    'name': tags.get('name', 'Unnamed'),
                    'type': tags.get('tourism', 'hotel'),
                    'lat': element['lat'],
                    'lon': element['lon'],
                    'stars': tags.get('stars', ''),
                    'phone': tags.get('phone', ''),
                    'website': tags.get('website', '')
                })

        print(f"  ✓ Found {len(hotels)} hotels/accommodations")
        return hotels
    except Exception as e:
        print(f"  ✗ Error fetching hotels: {e}")
        return []

def fetch_villages_for_route(route_coords):
    """Fetch villages near a specific route"""
    # Get bounding box for this specific route
    all_lats = []
    all_lons = []
    for way_coords in route_coords:
        for lat, lon in way_coords:
            all_lats.append(lat)
            all_lons.append(lon)

    if not all_lats or not all_lons:
        return []

    min_lat, max_lat = min(all_lats), max(all_lats)
    min_lon, max_lon = min(all_lons), max(all_lons)

    # Add padding
    lat_padding = (max_lat - min_lat) * 0.1
    lon_padding = (max_lon - min_lon) * 0.1

    overpass_url = "https://overpass-api.de/api/interpreter"

    overpass_query = f"""
    [out:json][timeout:60];
    (
      node["place"="village"]({min_lat - lat_padding},{min_lon - lon_padding},{max_lat + lat_padding},{max_lon + lon_padding});
    );
    out body;
    """

    try:
        response = requests.post(overpass_url, data={'data': overpass_query}, timeout=120)
        response.raise_for_status()
        data = response.json()

        places = []
        for element in data.get('elements', []):
            if element['type'] == 'node' and 'lat' in element and 'lon' in element:
                tags = element.get('tags', {})
                places.append({
                    'name': tags.get('name', 'Unnamed'),
                    'lat': element['lat'],
                    'lon': element['lon'],
                    'population': tags.get('population', ''),
                    'wikipedia': tags.get('wikipedia', '')
                })

        return places
    except Exception as e:
        print(f"      ✗ Error fetching villages: {e}")
        return []

def print_route_info(route_num, bus_stops):
    """Print detailed information about bus stops"""
    print(f"\n{'='*70}")
    print(f"Bus {route_num} - Stop Details")
    print(f"{'='*70}")

    if not bus_stops:
        print("  No stops found")
        return

    # Remove duplicates based on name
    unique_stops = {}
    for stop in bus_stops:
        if stop['name'] not in unique_stops:
            unique_stops[stop['name']] = stop

    stops_list = list(unique_stops.values())

    print(f"Total Stops: {len(stops_list)}\n")

    for i, stop in enumerate(stops_list, 1):
        ref = f" [{stop['ref']}]" if stop['ref'] else ""
        print(f"{i:3d}. {stop['name']}{ref}")
        print(f"      Location: {stop['lat']:.5f}°N, {stop['lon']:.5f}°E")

def print_hotel_info(hotels):
    """Print detailed information about hotels"""
    print(f"\n{'='*70}")
    print(f"Hotels and Accommodations Near Routes")
    print(f"{'='*70}")

    if not hotels:
        print("  No hotels found")
        return

    # Sort by type
    hotels_by_type = {}
    for hotel in hotels:
        htype = hotel['type']
        if htype not in hotels_by_type:
            hotels_by_type[htype] = []
        hotels_by_type[htype].append(hotel)

    for htype, hlist in hotels_by_type.items():
        print(f"\n{htype.upper()}S ({len(hlist)}):")
        for hotel in sorted(hlist, key=lambda x: x['name']):
            stars = f" {'★' * int(hotel['stars'])}" if hotel['stars'] else ""
            print(f"  • {hotel['name']}{stars}")
            print(f"    Location: {hotel['lat']:.5f}°N, {hotel['lon']:.5f}°E")
            if hotel['phone']:
                print(f"    Phone: {hotel['phone']}")
            if hotel['website']:
                print(f"    Website: {hotel['website']}")

def create_villages_by_route_chart(villages_by_route):
    """Create a chart showing villages grouped by bus route"""
    print("\nCreating villages by route chart...")

    # Prepare data - organize by route
    route_data = {}
    for route_num in ['660', '670', '673']:
        if route_num in villages_by_route and villages_by_route[route_num]:
            villages = villages_by_route[route_num]
            route_data[route_num] = sorted([v['name'] for v in villages])

    if not route_data:
        print("  No villages to chart")
        return

    # Get all unique villages
    all_villages = set()
    for villages in route_data.values():
        all_villages.update(villages)
    all_villages = sorted(list(all_villages))

    # Create figure
    fig, ax = plt.subplots(figsize=(16, 12))

    # Color map for routes
    colors_map = {
        '660': '#FF0000',  # Red
        '670': '#00FFFF',  # Cyan
        '673': '#FFD700'   # Gold
    }

    route_names = {
        '660': 'Bus 660\nZell am See ↔ Kaprun',
        '670': 'Bus 670\nZell am See ↔ Krimml',
        '673': 'Bus 673\nWald/Pzg ↔ Königsleiten'
    }

    # Plot data
    x_positions = {'660': 0, '670': 1, '673': 2}

    for route_num, villages in route_data.items():
        x_pos = x_positions[route_num]
        y_positions = [all_villages.index(v) for v in villages]

        # Plot dots for each village on this route
        ax.scatter([x_pos] * len(villages), y_positions,
                  c=colors_map[route_num],
                  s=500,
                  alpha=0.8,
                  edgecolors='white',
                  linewidths=3,
                  zorder=10)

    # Set axes
    ax.set_xticks([0, 1, 2])
    ax.set_xticklabels([route_names['660'], route_names['670'], route_names['673']],
                       fontsize=16, fontweight='bold')

    ax.set_yticks(range(len(all_villages)))
    ax.set_yticklabels(all_villages, fontsize=14)

    ax.set_xlabel('Bus Route', fontsize=18, fontweight='bold', labelpad=15)
    ax.set_ylabel('Villages', fontsize=18, fontweight='bold', labelpad=15)
    ax.set_title('Villages Served by Each Bus Route', fontsize=22, fontweight='bold', pad=20)

    # Grid
    ax.grid(True, axis='y', alpha=0.3, linestyle='--', linewidth=1)
    ax.set_xlim(-0.5, 2.5)
    ax.set_ylim(-0.5, len(all_villages) - 0.5)

    # Add legend
    from matplotlib.patches import Patch
    legend_elements = [
        Patch(facecolor='#FF0000', edgecolor='white', label='Bus 660'),
        Patch(facecolor='#00FFFF', edgecolor='white', label='Bus 670'),
        Patch(facecolor='#FFD700', edgecolor='white', label='Bus 673')
    ]
    ax.legend(handles=legend_elements, loc='upper right', fontsize=14, framealpha=0.95)

    plt.tight_layout()

    # Save
    filename = 'salzburg_villages_by_route_chart.png'
    plt.savefig(filename, dpi=300, bbox_inches='tight', facecolor='white')
    print(f"  ✓ Chart saved as '{filename}'")
    plt.show()
    """Print detailed information about villages by route"""
    print(f"\n{'='*70}")
    print(f"Villages Along Each Route")
    print(f"{'='*70}")

    for route_num, villages in villages_by_route.items():
        route_name = bus_routes[route_num]['name']
        print(f"\n{route_name}")
        print("-" * 70)

        if not villages:
            print("  No villages found")
            continue

        print(f"Total: {len(villages)} villages\n")

        for i, village in enumerate(sorted(villages, key=lambda x: x['name']), 1):
            pop_info = f" (pop: {village['population']})" if village['population'] else ""
            print(f"{i:3d}. {village['name']}{pop_info}")
            print(f"      Location: {village['lat']:.5f}°N, {village['lon']:.5f}°E")
            if village['wikipedia']:
                print(f"      Wikipedia: {village['wikipedia']}")

def plot_routes_with_stops_and_hotels():
    """Main plotting function with stops and hotels"""
    print("="*70)
    print("Salzburg Bus Routes - Detailed Analysis")
    print("="*70)
    print("\nFetching route data from OpenStreetMap...")

    # Fetch all routes
    route_data = {}
    all_coords = []
    all_stops = {}
    villages_by_route = {}

    for route_num, route_info in bus_routes.items():
        print(f"\n[Bus {route_num}] {route_info['name']}")
        route_coords = []
        route_stops = []

        for relation_id in route_info['relations']:
            data = fetch_route_from_overpass(relation_id)
            if data:
                coords, stops = extract_route_data(data)
                route_coords.extend(coords)
                route_stops.extend(stops)
                if coords:
                    print(f"      ✓ {len(coords)} segments, {len(stops)} stops")

        if route_coords:
            route_data[route_num] = route_coords
            all_coords.extend(route_coords)
            all_stops[route_num] = route_stops

            # Fetch villages for this specific route
            print(f"      Fetching villages for Bus {route_num}...")
            villages = fetch_villages_for_route(route_coords)
            villages_by_route[route_num] = villages
            print(f"      ✓ Found {len(villages)} villages")

            print(f"   → Total: {len(route_coords)} segments, {len(route_stops)} stops, {len(villages)} villages")
        else:
            print(f"   ✗ No data found")

    if not all_coords:
        print("\n✗ No route data available!")
        return

    # Get coordinate bounds
    all_lats = []
    all_lons = []
    for way_coords in all_coords:
        for lat, lon in way_coords:
            all_lats.append(lat)
            all_lons.append(lon)

    min_lat, max_lat = min(all_lats), max(all_lats)
    min_lon, max_lon = min(all_lons), max(all_lons)

    # Fetch hotels
    hotels = fetch_hotels_near_route(min_lat, max_lat, min_lon, max_lon)

    # Print detailed information
    for route_num, stops in all_stops.items():
        print_route_info(route_num, stops)

    print_villages_info(villages_by_route)
    print_hotel_info(hotels)

    # Create villages by route chart
    create_villages_by_route_chart(villages_by_route)

    print(f"\n{'='*70}")
    print("Creating visualization...")
    print(f"{'='*70}")

    # Create plot with much larger size
    fig, ax = plt.subplots(figsize=(40, 30))

    # Set nice background
    ax.set_facecolor('#F5F5F5')
    ax.grid(True, alpha=0.3, linestyle='--', linewidth=1.5, color='#888888')

    # Plot routes with much thicker lines
    print("\nPlotting routes...")
    for route_num, coords_list in route_data.items():
        route_info = bus_routes[route_num]
        for way_coords in coords_list:
            if len(way_coords) >= 2:
                lats, lons = zip(*way_coords)
                ax.plot(lons, lats,
                       color=route_info['color'],
                       linewidth=12,
                       alpha=0.8,
                       solid_capstyle='round',
                       zorder=5)

    # Plot bus stops - much larger
    print("Plotting bus stops...")
    for route_num, stops in all_stops.items():
        route_info = bus_routes[route_num]
        if stops:
            stop_lats = [s['lat'] for s in stops]
            stop_lons = [s['lon'] for s in stops]
            ax.scatter(stop_lons, stop_lats,
                      c=route_info['color'],
                      s=600,
                      marker='o',
                      edgecolors='white',
                      linewidths=5,
                      alpha=0.9,
                      zorder=10,
                      label=f'Bus {route_num} stops')

    # Plot hotels - much larger
    print("Plotting hotels...")
    if hotels:
        hotel_lats = [h['lat'] for h in hotels]
        hotel_lons = [h['lon'] for h in hotels]
        ax.scatter(hotel_lons, hotel_lats,
                  c='#8B4513',  # Brown
                  s=800,
                  marker='s',  # Square
                  edgecolors='white',
                  linewidths=5,
                  alpha=0.8,
                  zorder=15,
                  label=f'Hotels ({len(hotels)})')

    # Plot villages by route with different colors - much larger
    print("Plotting villages by route...")
    if villages_by_route:
        # Color villages by which route they belong to
        for route_num, villages in villages_by_route.items():
            route_info = bus_routes[route_num]
            if villages:
                for village in villages:
                    # Use a lighter shade of the route color for villages
                    ax.scatter(village['lon'], village['lat'],
                              c=route_info['color'],
                              s=700,
                              marker='^',  # Triangle
                              edgecolors='white',
                              linewidths=5,
                              alpha=0.7,
                              zorder=12)

                    # Add village name as text with route-colored box - much larger
                    ax.annotate(village['name'],
                               xy=(village['lon'], village['lat']),
                               xytext=(10, 10),
                               textcoords='offset points',
                               fontsize=22,
                               fontweight='bold',
                               color='#000000',
                               bbox=dict(boxstyle='round,pad=0.8',
                                        facecolor=route_info['color'],
                                        edgecolor='white',
                                        linewidth=3,
                                        alpha=0.8),
                               zorder=20)

    # Set bounds with padding
    lat_padding = (max_lat - min_lat) * 0.05
    lon_padding = (max_lon - min_lon) * 0.05

    ax.set_xlim(min_lon - lon_padding, max_lon + lon_padding)
    ax.set_ylim(min_lat - lat_padding, max_lat + lat_padding)

    # Create custom legend
    legend_elements = []

    # Routes
    for route_num in ['660', '670', '673']:
        if route_num in route_data:
            info = bus_routes[route_num]
            legend_elements.append(
                Line2D([0], [0], color=info['color'], linewidth=4,
                       label=info['name'])
            )

    # Stops and hotels
    legend_elements.append(
        Line2D([0], [0], marker='o', color='w',
               markerfacecolor='gray', markersize=10,
               markeredgecolor='white', markeredgewidth=2,
               label='Bus Stops', linestyle='None')
    )

    if hotels:
        legend_elements.append(
            Line2D([0], [0], marker='s', color='w',
                   markerfacecolor='#8B4513', markersize=10,
                   markeredgecolor='white', markeredgewidth=2,
                   label=f'Hotels/Accommodations ({len(hotels)})',
                   linestyle='None')
        )

    if villages:
        legend_elements.append(
            Line2D([0], [0], marker='^', color='w',
                   markerfacecolor='#4169E1', markersize=10,
                   markeredgecolor='white', markeredgewidth=2,
                   label=f'Villages ({len(villages)})',
                   linestyle='None')
        )

    ax.legend(handles=legend_elements,
             loc='upper right',
             fontsize=13,
             framealpha=0.95,
             edgecolor='black',
             shadow=True)

    # Labels and title - much larger text
    ax.set_xlabel('Longitude (°E)', fontsize=28, fontweight='bold', labelpad=15)
    ax.set_ylabel('Latitude (°N)', fontsize=28, fontweight='bold', labelpad=15)

    # Larger tick labels
    ax.tick_params(axis='both', which='major', labelsize=24, width=2, length=10)

    total_stops = sum(len(stops) for stops in all_stops.values())
    total_villages = sum(len(v) for v in villages_by_route.values())
    ax.set_title(f'Salzburg Regional Bus Routes - Detailed Map\n'
                 f'Lines 660, 670, 673 | {total_stops} stops | {total_villages} villages | {len(hotels)} hotels',
                 fontsize=36, fontweight='bold', pad=30)

    # Attribution - larger
    ax.text(0.02, 0.02, '© OpenStreetMap contributors',
            transform=ax.transAxes, fontsize=18,
            verticalalignment='bottom',
            bbox=dict(boxstyle='round,pad=0.8', facecolor='white',
                     edgecolor='black', linewidth=2, alpha=0.9))

    ax.set_aspect('equal', adjustable='box')
    plt.tight_layout()

    # Save
    filename = 'salzburg_bus_routes_detailed.png'
    plt.savefig(filename, dpi=300, bbox_inches='tight', facecolor='white')
    print(f"\n✓ Map saved as '{filename}'")

    # Display
    print("✓ Displaying map...")
    plt.show()

    print("\n" + "="*70)
    print("Analysis Complete!")
    print(f"Routes: {len(route_data)}")
    print(f"Total Stops: {sum(len(stops) for stops in all_stops.values())}")
    print(f"Villages: {sum(len(v) for v in villages_by_route.values())}")
    print(f"Hotels Found: {len(hotels)}")
    print("="*70)

if __name__ == "__main__":
    try:
        plot_routes_with_stops_and_hotels()
    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
    except Exception as e:
        print(f"\n✗ Error: {e}")
        import traceback
        traceback.print_exc()

